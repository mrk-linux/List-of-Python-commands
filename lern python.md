# __*vscode*__

- [__*vscode*__](#vscode)
- [عمل گر مقایسه ای](#عمل-گر-مقایسه-ای)
- [عملگرهای انتساب](#عملگرهای-انتساب)
- [عملگرهای منطقی](#عملگرهای-منطقی)
- [**split**](#split)
- [join](#join)
- [کاراکتر بک‌اسلش (\\)](#کاراکتر-بکاسلش-)
- [تکه  بندی](#تکه--بندی)
    - [(f-string)فرمت دهی رشته با](#f-stringفرمت-دهی-رشته-با)
- [لیست](#لیست)
    - [ویژگی‌های کلیدی:](#ویژگیهای-کلیدی)
    - [دستورات پرکاربرد](#دستورات-پرکاربرد)
- [دیکشنری](#دیکشنری)
  - [تعریف دیکشنری](#تعریف-دیکشنری)
  - [ویژگی‌های کلیدی:](#ویژگیهای-کلیدی-1)
  - [روش‌های ایجاد دیکشنری:](#روشهای-ایجاد-دیکشنری)
  - [متدهای مهم:](#متدهای-مهم)
  - [مثال پیشرفته:](#مثال-پیشرفته)
- [حلقه](#حلقه)
  - [انواع حلقه‌ها :](#انواع-حلقهها-)
    - [1. حلقه `for` (برای تکرار روی دنباله‌ها)](#1-حلقه-for-برای-تکرار-روی-دنبالهها)
    - [2. حلقه `while` (برای تکرار شرطی)](#2-حلقه-while-برای-تکرار-شرطی)
  - [کنترل جریان حلقه‌ها](#کنترل-جریان-حلقهها)
    - [1. `break` (خروج از حلقه)](#1-break-خروج-از-حلقه)
    - [2. `continue` (رد کردن یک تکرار)](#2-continue-رد-کردن-یک-تکرار)
    - [3. `else` (پس از اتمام حلقه)](#3-else-پس-از-اتمام-حلقه)
    - [4.  enumerate](#4--enumerate)
  - [تکنیک‌های پیشرفته](#تکنیکهای-پیشرفته)
    - [1. حلقه با `range()`](#1-حلقه-با-range)
    - [2. حلقه روی دیکشنری](#2-حلقه-روی-دیکشنری)
    - [3. حلقه‌های تو در تو](#3-حلقههای-تو-در-تو)
    - [4. فهرست‌سازی (List Comprehension)](#4-فهرستسازی-list-comprehension)
  - [نکات مهم:](#نکات-مهم)
  - [مثال کاربردی:](#مثال-کاربردی)
- [zip](#zip)
- [تابع](#تابع)
    - [1. برای تعریف تابع از کلمه کلیدی ``def`` استفاده می‌شود:](#1-برای-تعریف-تابع-از-کلمه-کلیدی-def-استفاده-میشود)
    - [**2.انواع پارامترها**](#2انواع-پارامترها)
      - [**الف) پارامترهای معمولی**](#الف-پارامترهای-معمولی)
      - [**ب) پارامترهای نام‌دار (Keyword Arguments)**](#ب-پارامترهای-نامدار-keyword-arguments)
      - [**ج) پارامترهای نامحدود (`*args` و `**kwargs`)**](#ج-پارامترهای-نامحدود-args-و-kwargs)
    - [**3. return**](#3-return)
    - [**4. توابع بازگشتی (Recursive)**](#4-توابع-بازگشتی-recursive)
    - [**5. توابع لامبدا (Lambda)**](#5-توابع-لامبدا-lambda)
    - [**6. دکوراتورها (Decorators)**](#6-دکوراتورها-decorators)
    - [مثال](#مثال)
    - [**نکات مهم:**](#نکات-مهم-1)
- [یادداشت تابع (function annotation)](#یادداشت-تابع-function-annotation)
  - [مثال](#مثال-1)
- [توابع لامبدا](#توابع-لامبدا)
  - [1. ساختار توابع لامدا:](#1-ساختار-توابع-لامدا)
  - [2. دستورات لامدا](#2-دستورات-لامدا)
    - [1. تابع map:](#1-تابع-map)
    - [2. تابع filter:](#2-تابع-filter)
    - [3. تابع reduce:](#3-تابع-reduce)
    - [4. تابع sorted:](#4-تابع-sorted)
- [pass](#pass)
- [DocString](#docstring)
- [**تکرار (Iteration)**](#تکرار-iteration)
  - [**1. حلقه `for` — تکرار بر روی عناصر یک دنباله**](#1-حلقه-for--تکرار-بر-روی-عناصر-یک-دنباله)
    - [**سینتکس پایه:**](#سینتکس-پایه)
    - [**مثال‌ها:**](#مثالها)
      - [**الف) تکرار روی لیست**](#الف-تکرار-روی-لیست)
      - [**ب) تکرار روی رشته**](#ب-تکرار-روی-رشته)
      - [**ج) تکرار روی دیکشنری**](#ج-تکرار-روی-دیکشنری)
  - [**2. حلقه `while` — تکرار تا زمانی که شرط برقرار است**](#2-حلقه-while--تکرار-تا-زمانی-که-شرط-برقرار-است)
    - [**سینتکس پایه:**](#سینتکس-پایه-1)
    - [**مثال‌ها:**](#مثالها-1)
      - [**الف) شمارش معکوس**](#الف-شمارش-معکوس)
      - [**ب) دریافت ورودی تا زمانی که کاربر "exit" وارد کند**](#ب-دریافت-ورودی-تا-زمانی-که-کاربر-exit-وارد-کند)
  - [**3. کنترل جریان حلقه‌ها (`break`, `continue`, `else`)**](#3-کنترل-جریان-حلقهها-break-continue-else)
    - [**الف) `break` — خروج زودهنگام از حلقه**](#الف-break--خروج-زودهنگام-از-حلقه)
    - [**ب) `continue` — رد کردن یک تکرار**](#ب-continue--رد-کردن-یک-تکرار)
    - [**ج) `else` — اجرای کد پس از اتمام حلقه**](#ج-else--اجرای-کد-پس-از-اتمام-حلقه)
  - [**4. توابع تکرارپذیر (`range`, `enumerate`, `zip`)**](#4-توابع-تکرارپذیر-range-enumerate-zip)
    - [**الف) `range()` — تولید دنباله‌ای از اعداد**](#الف-range--تولید-دنبالهای-از-اعداد)
    - [**ب) `enumerate()` — دریافت ایندکس و مقدار**](#ب-enumerate--دریافت-ایندکس-و-مقدار)
    - [**ج) `zip()` — ترکیب دو لیست**](#ج-zip--ترکیب-دو-لیست)
  - [**5. List Comprehension — تکرار فشرده برای ساخت لیست**](#5-list-comprehension--تکرار-فشرده-برای-ساخت-لیست)
  - [**6. توابع بازگشتی (Recursive Functions)**](#6-توابع-بازگشتی-recursive-functions)
  - [**نتیجه‌گیری**](#نتیجهگیری)
- [Decorator](#decorator)
  - [دکوراتور چیست؟](#دکوراتور-چیست)
  - [دکوراتورهای استاندارد پایتون](#دکوراتورهای-استاندارد-پایتون)
  - [کاربردهای رایج دکوراتورها](#کاربردهای-رایج-دکوراتورها)
  - [فرم کلی](#فرم-کلی)
  - [مثال :](#مثال-)
  - [نکات مهم](#نکات-مهم-2)
  - [جمع‌بندی](#جمعبندی)
- [شی گرای](#شی-گرای)
  - [ایجاد کلاس](#ایجاد-کلاس)

#  عمل گر مقایسه ای
- == : equal
- != : not equal
- .> :  greatel than    //همان
- <  :  less than       
- .>= :  greater than or equal to    //کوچیک تر مساوی
- <= : less than or equal to

# عملگرهای انتساب
- +=  x=x+2
- -=  x=x-2
- *=  x=x*2
- /=  x=x/2
- %=  x=x%2       //باقی مانده
-  //=  x=x//2
-  **=  x=x**2      //توان 2

```
    x = 4
    x += 2;
    print(x);       //پرینت می کنه 6
```
# عملگرهای منطقی
![alt text](<picture-lening/عملگرهای منطقی.png>)

- ما می توان با دستور + دو تا رشته را به هم جمع کنیم
>print("x"+"y")

- دستور را چندین بار تکرار میکند
>print(4*"alireza")

- اخرین رقم ان عدد را نشان می دهد
print(هر عددی %10)

- به میزانی که عدد گذاشتیم  عدد را رند می کند
>print(round(motegaier, 2))

- متوجه میشیم که یک متغیر جزو کدام نوع داده هست
>print(isinstance(نوع متغیر ,  متغیر))

- تعداد تکرار را میشمرد
>[رشته].count()

- فضای خالی از سمت راست را پاک می کند
>[رشته].rstrip

- پیدا می کند از داخل رشته 
>[رشته].find

- یک کارکتر چند بار تکرار شده
>تابع.count('یک کارکتر از تابع')

- برسی می کند که یک تابع با یک کارکتر خاص به اتمام رسیده است یا خیر
>تابع. endswith("کارکتر")

- برسی می کند که یک تابع با یک کارکتر خاص شروع شده یا خیر
>تابع. startswith("کارکتر")

- کارکتر  را پیدا میکند
- ایندکس ان  (از سمت چپ شروع می شود)
> تابع . find ('کارکتر') 

- نشان میده که کل کارکتر فقط عدد است یا نه
>تابع . isnumeric()


- > تابع . replace ('کارکتر که می خوایم عوض بشه ', 'کارکتری که جایگذاری بشه')

- اگر داخل پرانتز خالی باشد فاصله در نظر می گیرد ; فاصله های اضاقی از ابتدا و انتهای را پاک می کند
>تابع . strip()

- از سمت چپ فقط پاک میکند
>تابع . lreplace

- مقدار تکرار یک چیز را می شمارد
>c . count(تابع)

- یونیکد
>ord()

- مقادیر را مرتب می کند
>sorted() 

- نوع رشته را مشخص میکند
>(type(رشته))

# **split**
-  این دستور ترکیبی از دو عمل اصلی است که برای دریافت ورودی از کاربر و تقسیم آن به بخش‌های جداگانه استفاده می‌شود:

- .split()
  - متدی برای رشته‌ها که آنها را بر اساس جداکننده (پیش‌فرض: فاصله) تقسیم می‌کند

  - نتیجه یک لیست از زیررشته‌ها است
  
  ```py
  data = input("enter: ").split(',')
   ورودی: "علی,رضا,مریم" 
   → ['علی', 'رضا', 'مریم']
  ```
# join
- دو تابع را به یک دیگر متصل می کند
```py
s = "*"
l + ["a" , "b" , "c"]
print(s.join(l))
===> a*b*c
```
# کاراکتر بک‌اسلش (\\)
- (\دستور) ----- کار این دستور لغو کردن دستورات است

-  \n ------ می رود خط بعدی
-  \\\ ----- c:\alireza\new    ==>   c:\alireza\\\new 
- \t ------- یک تب فاصله می دهد
- اگر قبل رشته دستور (r')بزنیم  تمام دستورات  \ را لغو می کند
- \b ------ حرف قبلی را پاک می کند

# تکه  بندی
- برای اینکه بتوانیم ایندکس یک رشته را بگیریم 
  - (s[ایندکس])

- برای چاپ کردن یک بخشی از رشته 
  - (رشته[ایندکس: ایندکس]) 
  -  اگر در هر قسمت ایندکس نگذاریم تا اخر رشته را استفاده می کند

- طول گام را مشخص می کند 
  - ([گام: ایندکس :ایندکس]رشته)

- (len(رشته))     سایز رشته را نشان می  دهد

- (رشته[::])  رشته را معکوس می کند

### (f-string)فرمت دهی رشته با 
```py
name = "alireza"
age = 18

msg =(
f"name: {name}\n"
f'age: {age}\n
     )

print(msg)

autput= name: alireza
       age:18
```
# لیست
 لیست یک ساختار داده‌ی تغییرپذیر و ترتیبی در پایتون است که می‌تواند عناصر مختلف را ذخیره کند .
> my_list = [1, "دو", 3.0, True]  # ایجاد لیست با انواع داده مختلف
### ویژگی‌های کلیدی:
1. تغییرپذیر (Mutable): محتوا قابل تغییر است
> my_list[0] = 10  # تغییر اولین عنصر 
2. ترتیبی (Ordered): ترتیب عناصر حفظ می‌شود
3. پشتیبانی از انواع داده مختلف:
> mixed = [1, "text", 3.14, [1, 2]]  # لیست در لیست
-  `متدهای پرکاربرد`
``` 
1.  print(my_list[0])  # اولین عنصر (ایندکس 0)
2.  print(my_list[-1]) # آخرین عنصر
3. print(my_list[1:3])  # عناصر از ایندکس 1 تا 2
4. my_list.append(4)       # اضافه کردن به انتها
5. my_list.insert(1, 1.5)  # درج در موقعیت خاص
6. my_list.remove("دو")    # حذف مقدار خاص
7. popped = my_list.pop()  # حذف و بازگرداندن آخرین عنصر
8. len(my_list)      # طول لیست
9. my_list.sort()    # مرتب‌سازی
10. my_list.reverse() # معکوس کردن ترتیب
```
- `نکته`
  - با گذاشتن ستاره قبل از یک کارکتر کارکتر را تبدیل به لیست میکند
```py
a, b, *c = [1, 2, 3, 4, 5, 6]
print(a, b, c)

autput = 1      2       [3, 4, 5, 6]
```
### دستورات پرکاربرد 
1. **reversed** = یکی از لیست ها را معکوس می کند
```python
x = ['Alice', 'Bob', 'Charlie']
y = [25, 30, 35]
for i, j in reversed(x,y):
   print(i)
```
2. **sorted**
 (به ترتیب حرف الف با)تمامی لیست را مرتب می کند 
```python
x = ['Alice', 'Bob', 'Charlie']
y = [25, 30, 35]
for i, j in sorted(x):
    print(i)
```
3. **random**
  min + (random * (max - min)) عدد رندوم در بازه ای که میخوایم تولید می کند
-  random.uniform یک تابع از ماژول random است که برای تولید اعداد تصادفی با توزیع یکنواخت پیوسته (Continuous Uniform Distribution) استفاده می‌شود. این تابع یک عدد اعشاری تصادفی در بازه مشخص شده ([a, b]) برمی‌گرداند که همه مقادیر در این بازه احتمال یکسانی دارند.

- تفاوت random.uniform با random.random:
  - random.random() فقط اعداد بین ۰.۰ تا ۱.۰ تولید می‌کند.

  - random.uniform(a, b) اعداد بین a تا b (شامل a و b) تولید می‌کند.
```python
import random

# با random.random
rand1 = random.random()  # مثلاً 0.74321

# با random.uniform
rand2 = random.uniform(5, 10)  # مثلاً 7.8321
```
```python
#مثال
#(تولید عدد رندوم در بازه بیت 5 تا 10 )
from random import random
for _ in range(10):
    print(5 + (random() * (10 - 5)))
  
#مثال 2
from random import random
for _ in range(10):
    print(5 + (random() * (10)))
 
#random uniform
  
from random import random, uniform
for _ in range(10):
    print(uniform(5,10))
 
#تولید عدد رندوم intger
  
from random import randint
for _ in range(10):
    print(randint(5, 16))
 
#تولید عدد رندوم با طول گام
 
from random import randrange
for _ in range(10):
    print(randrange(5, 50, 3))
 
 
#از بازه موجود به صورت رندوم یک را انتخاب می کند
from random import choice
x = ["a", "b", "c","d"]
for _ in range(10):
    print(choice(x))
 
#یک زیر لیست از لیست درست می کند
 
from random import sample
x = ["a", "b", "c","d"]
print(sample(x, 2))
print(x)
```
`نکته:`
 اگر می خواهیم بعد از تولید یک زیر لیست ,  زیر لیست تغیر نکند از دستور
 (**seed**) استقاده می کنیم
```python
from random import sample, seed
x = ["a", "b", "c","d"]
seed(10)
print(sample(x, 2))
print(x)
```
4.  **shuffle**
  بور می زند یعنی لبست من را شانسی بور می زند
```python
from random import shuffle
x = ["a", "b", "c","d"]
shuffle(x)
print(x)
```
# دیکشنری

## تعریف دیکشنری
- دیکشنری (Dictionary) یک ساختار داده‌ی **تغییرپذیر**، **نامرتب** و **ایندکس‌گذاری شده با کلید** در پایتون است که داده‌ها را به صورت جفت‌های `کلید: مقدار` ذخیره می‌کند.

```python
my_dict = {"name": "علی", "age": 25, "city": "تهران"}
```

## ویژگی‌های کلیدی:
1. **تغییرپذیر (Mutable)**: مقادیر قابل تغییر هستند
2. **نامرتب (Unordered)**: ترتیب عناصر حفظ نمی‌شود (تا پایتون 3.6)
3. **عدم اجازه کلید تکراری**: هر کلید فقط یک بار می‌تواند وجود داشته باشد

## روش‌های ایجاد دیکشنری:
1. روش مستقیم:
   ```python
   person = {"name": "رضا", "age": 30}
   ```

2. استفاده از تابع `dict()`:
   ```python
   person = dict(name="نازنین", age=28)
   ```

3. از لیست تاپل‌ها:
   ```python
   pairs = [("one", 1), ("two", 2)]
   numbers = dict(pairs)
   ```

## متدهای مهم:
  - اگر بخواهیم یک متغیر تعریف کنیم که هیچ متغیر خاصی ندارد از **__none type__** استفاده می کنیم 
تابع = none
```python
keys = person.keys()    # لیست کلیدها
values = person.values()  # لیست مقادیر
items = person.items()   # لیست جفت‌های کلید-مقدار
```

## مثال پیشرفته:
```python
students = {
    1001: {"name": "علی", "grades": [18, 20, 16]},
    1002: {"name": "زهرا", "grades": [19, 17, 20]}
}

# محاسبه میانگین نمرات
for student_id, info in students.items():
    avg = sum(info["grades"]) / len(info["grades"])
    print(f"{info['name']}: {avg:.2f}")
```
# حلقه
## انواع حلقه‌ها :

### 1. حلقه `for` (برای تکرار روی دنباله‌ها)
```python
for item in sequence:
    # دستورات
```

مثال:
```python
fruits = ["سیب", "پرتقال", "موز"]
for fruit in fruits:
    print(fruit)
```

### 2. حلقه `while` (برای تکرار شرطی)
```python
while condition:
    # دستورات
```

مثال:
```python
count = 0
while count < 5:
    print(count)
    count += 1
```
مثال 2: 
```
n = int(input("x = "))
while n < 100:
    if n % 2 == 0 :
     print(n)
n += 1
اعداد زوج را چاپ می کند
```

## کنترل جریان حلقه‌ها

### 1. `break` (خروج از حلقه)
```python
for num in range(10):
    if num == 5:
        break
    print(num)
```
```python
n = float(input("n:"))
m = n
while True:
    s = input("do tou cantinue?")
    if s.lower() == "no":
        break
    n = float(input("n:"))
    if n < m :
        m = n
        print(m,"min:")
```

### 2. `continue` (رد کردن یک تکرار)
```python
for num in range(10):
    if num % 2 == 0:
        continue
    print(num)  # فقط اعداد فرد
```

### 3. `else` (پس از اتمام حلقه)
```python
for num in range(3):
    print(num)
else:
    print("حلقه کامل اجرا شد")
```
```python
i = 0
while i <10:
   i += 1
   if i % 3 == 0:
       break
    print(i)
else:
    print("ok")
autput
1
2
```
```python
n = int(input("n:"))
i = 2
if n > 1:
    while i < n:
        if n % i == 0:
            print(n,"is nat prime number")
            break
        i += 1
    else:
        print(n, "not prime number")
else:
    print(n,"is a not prime number")
#برسی می کند عدد اول هست یا نه
```
### 4.  enumerate
  تابع **enumerate** در پایتون به شما اجازه می‌دهد تا همزمان به اندیس و مقدار عناصر یک لیست دسترسی داشته باشید.

```python
  l = ["a", "b", "c", "d"]
  for i ,j enumerate(l):
     print(i, ":", j)
 
  autput
  0 : a
  1 : b
  3 : c
  4 : d
```
## تکنیک‌های پیشرفته

### 1. حلقه با `range()`
   اگر بخواهیم در حلقه (for )یک رنج تعریف کنیم از دستور  **range**استفاده می کنیم

-  range(طول گام ,  بازه )
```python
for i in range(5):       # 0 تا 4
for i in range(2, 6):    # 2 تا 5
for i in range(1, 10, 2): # 1 تا 9 با گام 2
```
مثال :
```python
   l = input("name:").split("-")
   print(l)
   for i in range(0, len(l)):
     print(i, L[i])
```

### 2. حلقه روی دیکشنری
```python
person = {"name": "علی", "age": 30}

for key in person:         # کلیدها
for value in person.values(): # مقادیر
for key, value in person.items(): # جفت‌ها
```

### 3. حلقه‌های تو در تو
```python
for i in range(3):
    for j in range(2):
        print(f"({i}, {j})")
```

### 4. فهرست‌سازی (List Comprehension)
```python
squares = [x**2 for x in range(10)]
```

## نکات مهم:
- از حلقه `for` برای تکرار روی اشیاء قابل پیمایش استفاده کنید
- از حلقه `while` وقتی تعداد تکرارها نامشخص است استفاده کنید
- از `break` و `continue` برای کنترل جریان استفاده کنید
- `range()` یک دنباله اعداد ایجاد می‌کند

## مثال کاربردی:
```python
# محاسبه فاکتوریل
n = 5
factorial = 1
for i in range(1, n+1):
    factorial *= i
print(f"!{n} = {factorial}")
```
# zip 
 دستور zip در پایتون دو یا چند لیست را گرفته و آن‌ها را به صورت زوج‌های (tuple) ترکیب می‌کند.
```python
x = ['Alice', 'Bob', 'Charlie']
y = [25, 30, 35]
for i, j in zip(x,y):
   print("name", i, "age", j)
```

# تابع
تابع (Function) در پایتون یک بلوک کد قابل استفاده مجدد است که یک کار خاص را انجام می‌دهد. توابع به سازماندهی کد، جلوگیری از تکرار و افزایش خوانایی کمک می‌کنند.

### 1. برای تعریف تابع از کلمه کلیدی ``def`` استفاده می‌شود:
```python
def نام_تابع(پارامترها):
    # بدنه تابع
    return نتیجه  # اختیاری
```
---

### **2.انواع پارامترها**
#### **الف) پارامترهای معمولی**

```python
def add(a, b):
    return a + b

print(add(3, 5))  # خروجی: 8
```

#### **ب) پارامترهای نام‌دار (Keyword Arguments)**

```python
def person_info(name, age):
    print(f"نام: {name}, سن: {age}")

person_info(age=25, name="رضا")  # ترتیب مهم نیست!
```

#### **ج) پارامترهای نامحدود (`*args` و `**kwargs`)**
- `*args` برای دریافت لیستی از مقادیر:
  ```python
  def sum_all(*numbers):
      return sum(numbers)

  print(sum_all(1, 2, 3))  # خروجی: 6
  ```

- `**kwargs` برای دریافت دیکشنری از پارامترهای نام‌دار:
  ```python
  def show_info(**details):
      for key, value in details.items():
          print(f"{key}: {value}")

  show_info(name="مریم", age=30, city="تهران")
  ```

---
### **3. return**
اگر ما از تابع استفاده کنیم و دستور(return) را استفاده نکنیم و بعد تابع را صدا بزنیم اخر کلمه `none`  را چاپ می کند 
- همیشه لازم نیست از (return)استفاده شود
```py
def f():
    x = int(input("x :"))
    print(2 * x + 1) 
f()
```
### **4. توابع بازگشتی (Recursive)**
تابعی که خودش را فراخوانی می‌کند.  
**مثال: محاسبه فاکتوریل:**
```python
def factorial(n):
    return 1 if n == 1 else n * factorial(n - 1)

print(factorial(5))  # 120
```

---

### **5. توابع لامبدا (Lambda)**
توابع کوچک و بی‌نام که با `lambda` تعریف می‌شوند:
```python
square = lambda x: x ** 2
print(square(4))  # 16
```

**کاربرد در `map` و `filter`:**
```python
numbers = [1, 2, 3]
squared = list(map(lambda x: x ** 2, numbers))  # [1, 4, 9]
```

---

### **6. دکوراتورها (Decorators)**
برای تغییر رفتار تابع بدون تغییر کد اصلی استفاده می‌شوند:
```python
def logger(func):
    def wrapper(*args, **kwargs):
        print(f"اجرای تابع {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@logger
def greet(name):
    print(f"سلام {name}!")

greet("علی")  # ابتدا "اجرای تابع greet" چاپ می‌شود.
```
---
### مثال
```py
f(x)= 2x+1
def f(x):
    return 2 x + 1 
print(f(1))

#مثال 2:
def f(x):
    return 2 * x + 1
y = int(input("y :"))
f(y)
print(f(y))
#مثال 3:
def f():
    x = int(input("x :"))
    return 2 * x + 1
print(f())
```
---

### **نکات مهم:**
1. نام تابع باید توصیفی باشد (مثل `calculate_area` به جای `func1`).
2. از توابع برای تقسیم کد به بخش‌های منطقی استفاده کنید.
3. توابع باید تا حد امکان مستقل از متغیرهای خارجی باشند.


# یادداشت تابع (function annotation)  
- در مقابل، پایتون به عنوان یک زبان داینامیک تایپ، به شما اجازه می‌دهد نوع پارامترها را مشخص نکنید و ارسال نوع داده اشتباه را در زمان اجرا تشخیص می‌دهد. این موضوع گاهی اوقات می‌تواند مشکل‌ساز باشد، زیرا ممکن است خطای نوع داده تا زمان اجرای برنامه مشخص نشود.

- برای حل این مشکل، پایتون از یادداشت تابع (Function Annotations) استفاده می‌کند. با استفاده از یادداشت تابع، می‌توان نوع پارامترها و نوع خروجی تابع را مشخص کرد.

- نکته مهم این است که یادداشت تابع در زمان اجرای عادی پایتون، هیچ تاثیری در عملکرد برنامه ندارد و صرفا برای راهنمایی برنامه‌نویس و ابزارهای توسعه مانند IDEها و Linterها استفاده می‌شود. برای مثال، PyCharm با استفاده از یادداشت تابع، می‌تواند خطاهای نوع داده را قبل از اجرا به شما نشان دهد.

- برای تشخیص خطاهای نوع داده در زمان اجرا، می‌توانید از ماژول mypy استفاده کنید. این ماژول با بررسی یادداشت تابع، خطاهای نوع داده را در زمان اجرا شناسایی می‌کند.

- نحوه تعریف نوع پارامترها با استفاده از یادداشت تابع به این صورت است که بعد از نام پارامتر، دو نقطه قرار داده و سپس نوع داده مورد نظر را می‌نویسیم.

- برای تعریف نوع خروجی تابع، باید بین دو نقطه و پرانتز تابع، یک فلش به سمت راست (->) قرار داده و سپس نوع داده خروجی را بنویسیم.

- همچنین می‌توان برای پارامترهای تابع، مقادیر پیش‌فرض تعیین کرد. در این صورت، اگر هنگام فراخوانی تابع، مقداری برای پارامتر ارسال نشود، از مقدار پیش‌فرض استفاده خواهد شد.

- برای مشاهده یادداشت تابع، می‌توان از __annotations__ استفاده کرد.

- در نهایت، می‌توان از انواع داده مختلف مانند دیکشنری، لیست و تاپل در یادداشت تابع استفاده کرد.

- به طور کلی، استفاده از یادداشت تابع در پایتون، می‌تواند به خوانایی کد و جلوگیری از خطاهای نوع داده کمک کند.

## مثال
```py
#مثال ۱: تابع ساده با ورودی و خروجی عددی
def func(x: int, y: int, z: int) -> int:
    return x + y + z

print(func(1, 2, 3))
#در این مثال، تابع func سه پارامتر ورودی از نوع int دریافت می‌کند و خروجی آن نیز از نوع int است.

# مثال ۲: تابع با مقدار پیش‌فرض
def func(x: int = 10, y: int = 9, z: int = 5):
print(x, y, z)

func() 
#در این مثال، برای هر یک از پارامترهای تابع func یک مقدار پیش‌فرض تعیین شده است. اگر تابع بدون ارسال آرگومان فراخوانی شود، از مقادیر پیش‌فرض استفاده خواهد شد.
#مثال ۳: تابع با نوع داده دیکشنری
def func(x: int, y: int, z: dict):
print(x)
print(y)
print(z)

func(1, 9, {}) 
#در این مثال، پارامتر z از نوع dict (دیکشنری) است.
# مثال ۴: تابع با نوع داده تاپل
def func(x: int, y: int, z: int) -> tuple:
    return (x+y+z, x, y, z)

print(func(1, 2, 5)) 
#در این مثال، نوع خروجی تابع func یک tuple (تاپل) است که شامل جمع سه عدد و خود اعداد می‌شود.


#    نکته: در تمامی این مثال‌ها، اگر نوع داده اشتباهی به تابع ارسال شود (مثلاً به جای عدد، رشته ارسال شود)، در زمان اجرای عادی پایتون خطایی رخ نمی‌دهد. اما اگر از ابزار mypy یا IDEهایی مانند PyCharm استفاده کنید، این خطاها قبل از اجرا یا در زمان اجرا شناسایی خواهند شد.
```
# توابع لامبدا
- لامبدا و کاربرد آن (map، filter، reduce و sorted)
- مفهوم توابع لامدا به عنوان توابع ناشناس و مختصر در پایتون توضیح داده می‌شود. این توابع برای مواقعی که نیاز به یک تابع کوچک و یکبار مصرف داریم، مفید هستند.

## 1. ساختار توابع لامدا:
توابع لامدا با استفاده از کلمه کلیدی lambda تعریف می‌شوند و ساختار آنها به صورت زیر است:
    lambda arguments: expression

- توابع لامبدا توابع ناشناسی هستند که در یک خط نوشته می‌شوند و اسم ندارند.  [1، 2] این توابع برای زمانی که به تابعی کوچک و یکبار مصرف نیاز دارید مفید هستند.

- **نحوه نوشتن یک تابع لامبدا:**

ابتدا کلمه کلیدی "لامبدا" را می‌نویسیم. سپس ورودی‌های تابع را با کاما از هم جدا می‌کنیم.  بعد از ورودی‌ها، دو نقطه قرار می‌دهیم و در جلوی دو نقطه عبارت یا بدنه تابع را می‌نویسیم.  نیازی به نوشتن دستور "ریترن" نیست زیرا به طور خودکار عبارت بعد از دو نقطه را برمی‌گرداند.

- ###  Arguments: ورودی‌های تابع که با کاما از هم جدا می‌شوند.

- ###  Expression: عبارتی که قرار است توسط تابع اجرا شود و نتیجه آن برگردانده شود.
**نکات مهم:**

    1. توابع لامدا نیازی به نام ندارند.
    
    2. بدنه این توابع فقط شامل یک عبارت است.
    
    3. نیازی به استفاده از دستور return نیست، زیرا عبارت به صورت خودکار برگردانده می‌شود.
**کاربردهای توابع لامدا:**

-توابع لامدا در کنار توابع و نوع‌های داخلی پایتون مانند map، filter، reduce و sorted کاربردهای فراوانی دارند.
## 2. دستورات لامدا

### 1. تابع map:
-تابع map دو آرگومان دریافت می‌کند: یک تابع و یک لیست. این تابع، عناصر لیست را یکی‌یکی به تابع ارسال می‌کند و نتیجه هر عنصر را در لیست جدیدی قرار می‌دهد.
```py
new_list = list(map(lambda x: x**2, my_list))

#در این مثال، هر عنصر لیست my_list به توان دو رسانده شده و نتیجه در لیست new_list قرار می‌گیرد.
```
### 2. تابع filter:
- تابع filter نیز دو آرگومان دریافت می‌کند: یک تابع و یک لیست. این تابع، عناصر لیست را یکی‌یکی به تابع ارسال می‌کند و اگر نتیجه تابع True باشد، عنصر را در لیست جدیدی قرار می‌دهد و در غیر این صورت آن را حذف می‌کند.
```py
new_list = list(filter(lambda x: x > 5, my_list))

#در این مثال، فقط عناصری از لیست my_list که بزرگتر از 5 هستند در لیست new_list قرار می‌گیرند.
```
### 3. تابع reduce:
- تابع reduce دو ورودی دریافت می‌کند: یک تابع و یک لیست. این تابع، دو عنصر اول لیست را به تابع ارسال می‌کند و نتیجه آن را با عنصر سوم لیست به تابع ارسال می‌کند و این کار را تا آخرین عنصر لیست ادامه می‌دهد.
```py
from functools import reduce

sum_of_list = reduce(lambda x, y: x + y, my_list)

#در این مثال، reduce جمع همه عناصر لیست my_list را محاسبه می‌کند.
```
### 4. تابع sorted:
- تابع sorted یک لیست را به عنوان ورودی دریافت می‌کند و یک لیست مرتب شده بر می‌گرداند. این تابع همچنین می‌تواند یک آرگومان اختیاری به نام key دریافت کند که یک تابع است و برای مرتب‌سازی عناصر لیست استفاده می‌شود.
```py
sorted_list = sorted(my_list, key=lambda x: len(x))

#در این مثال، sorted لیست my_list را بر اساس طول رشته‌ها مرتب می‌کند.
```
---

```python
lambda x: x ** 2
#در این مثال، تابع یک ورودی (x) می‌گیرد و آن را به توان دو می‌رساند.
```
**کاربردهای لامبدا:**

*   **مپ:** 
تابع `map` یک تابع و یک لیست را به عنوان ورودی می‌گیرد. این تابع، تابع ورودی را روی تک تک عناصر لیست اعمال کرده و لیست جدیدی با نتایج برمی‌گرداند.

**مثال:**
```python
my_list =
new_list = list(map(lambda x: x ** 2, my_list))
print(new_list)  # Output:
```
در این مثال، تابع لامبدا هر عنصر از لیست را به توان دو می‌رساند و `map` این تابع را روی تمام عناصر لیست `my_list` اعمال می‌کند. [4، 6]  

*   **فیلتر:** 
تابع `filter` یک تابع و یک لیست را به عنوان ورودی می‌گیرد. این تابع، عناصری از لیست را که تابع ورودی برای آنها مقدار `True` را برمی‌گرداند، نگه می‌دارد و بقیه را حذف می‌کند.

**مثال:**
```python
my_list =
new_list = list(filter(lambda x: x > 5, my_list))
print(new_list)  # Output:
```
در این مثال، تابع لامبدا بررسی می‌کند که آیا هر عنصر از لیست بزرگتر از 5 است یا خیر. [6، 7]  `filter` فقط عناصری را که تابع لامبدا برای آنها `True` را برمی‌گرداند، در لیست `new_list` قرار می‌دهد. [6، 7]

*   **ریدیوس:**
تابع `reduce` یک تابع و یک لیست را به عنوان ورودی می‌گیرد. این تابع، دو عنصر از لیست را به تابع ورودی ارسال می‌کند و نتیجه را با عنصر بعدی لیست ترکیب می‌کند تا در نهایت یک نتیجه نهایی به دست آید.

**مثال:**
```python
from functools import reduce
my_list =
result = reduce(lambda x, y: x + y, my_list)
print(result)  # Output: 10
```
در این مثال، تابع لامبدا دو ورودی (x و y) را دریافت کرده و آنها را با هم جمع می‌کند. [9، 10]  `reduce` از این تابع برای جمع کردن تمام عناصر لیست `my_list` استفاده می‌کند.

*   **مرتب‌سازی:**
تابع `sorted` یک لیست و یک تابع (اختیاری) را به عنوان ورودی می‌گیرد. این تابع، لیست را بر اساس خروجی تابع ورودی مرتب می‌کند.

**مثال:**
```python
my_list =
new_list = sorted(my_list, key=lambda x: x % 3)
print(new_list)  # Output:
```
در این مثال، تابع لامبدا باقی مانده تقسیم هر عنصر از لیست بر 3 را برمی‌گرداند.  `sorted` از این تابع برای مرتب‌سازی لیست `my_list` استفاده می‌کند. [10، 12]  

***نکته:*** در همه این مثال‌ها، به جای تعریف جداگانه تابع و ارسال آن به توابع `map`، `filter`، `reduce` و `sorted`، از توابع لامبدا برای تعریف تابع به صورت inline استفاده شده است. [6، 8، 10، 12]


# pass
از این دستور زمانی استفاده می کنیم که نمی خواهیم بدنه یک تابع یا حلقه ای را بنویسیم و بعدا بدنه  ان را می نویسیم از این دستور استفاده می کنیم

- خلاصه‌ای از ویدیو به همراه دستورات مورد نیاز

# DocString

**هدف از داک‌استرینگ توضیح عملکرد یک تابع، کلاس یا ماژول برای کاربران و برنامه‌نویسانی است که ممکن است کد را ننوشته باشند.**

**داک‌استرینگ چگونه تعریف می‌شود؟**
* برای تعریف داک‌استرینگ، کافیست در خط اول بعد از تعریف تابع، کلاس یا ماژول، یک رشته با سه علامت نقل قول ("") یا سه علامت نقل قول دوتایی (""") بنویسید.
* توصیه می‌شود از سه علامت نقل قول دوتایی استفاده شود.
*  متن داک‌استرینگ می‌تواند شامل خلاصه‌ای از عملکرد، پارامترهای ورودی، خروجی‌ها و توضیحات اضافی باشد.

**مثال:**
```python
def max_3(x, y, z):
   """
  این تابع سه عدد دریافت می‌کند و بزرگترین آنها را برمی‌گرداند.
 
  Args:
      x (int): اولین عدد
      y (int): دومین عدد
      z (int): سومین عدد

  Returns:
      int: بزرگترین عدد از بین سه عدد ورودی
  """
  # کد تابع 
  return max(x, y, z)
```
**نکات مهم:**
* داک‌استرینگ باید اولین خط بعد از تعریف تابع، کلاس یا ماژول باشد.
* استفاده از داک‌استرینگ اختیاری است، اما توصیه می‌شود برای توابع، کلاس‌ها و ماژول‌ها داک‌استرینگ بنویسید.
* داک‌استرینگ با کامنت فرق دارد. کامنت برای توضیح نحوه کار کد برای برنامه‌نویسان است، در حالی که داک‌استرینگ برای توضیح عملکرد کد برای کاربران است.

**دستورات مورد نیاز برای دسترسی به داک‌استرینگ:**
* با استفاده از اتریبیوت `__doc__`  :
```python
print(max_3.__doc__)
```
* با استفاده از تابع `help()` :
```python
help(max_3)
```

اکثر توابع داخلی پایتون دارای داک‌استرینگ هستند. برای مثال:
```python
print(len.__doc__)
print(print.__doc__)
print(max.__doc__)
```

# **تکرار (Iteration)**

در پایتون، **تکرار (Iteration)** به فرآیند اجرای مکرر یک بلوک کد گفته می‌شود. این کار معمولاً با استفاده از **حلقه‌ها (Loops)** یا **توابع بازگشتی (Recursive Functions)** انجام می‌شود. در اینجا به بررسی روش‌های مختلف تکرار در پایتون می‌پردازیم.

---

## **1. حلقه `for` — تکرار بر روی عناصر یک دنباله**
حلقه `for` برای **تکرار روی عناصر یک دنباله** (مانند لیست، رشته، تاپل، دیکشنری و ...) استفاده می‌شود.

### **سینتکس پایه:**
```python
for متغیر in دنباله:
    # کدی که تکرار می‌شود
```

### **مثال‌ها:**
#### **الف) تکرار روی لیست**
```python
fruits = ["سیب", "پرتقال", "موز"]
for fruit in fruits:
    print(fruit)
```
**خروجی:**
```
سیب
پرتقال
موز
```

#### **ب) تکرار روی رشته**
```python
name = "پایتون"
for char in name:
    print(char)
```
**خروجی:**
```
پ
ا
ی
ت
و
ن
```

#### **ج) تکرار روی دیکشنری**
```python
person = {"name": "علی", "age": 25, "city": "تهران"}
for key, value in person.items():
    print(f"{key}: {value}")
```
**خروجی:**
```
name: علی
age: 25
city: تهران
```

---

## **2. حلقه `while` — تکرار تا زمانی که شرط برقرار است**
حلقه `while` تا زمانی که **شرط آن `True` باشد** اجرا می‌شود.

### **سینتکس پایه:**
```python
while شرط:
    # کدی که تکرار می‌شود
```

### **مثال‌ها:**
#### **الف) شمارش معکوس**
```python
count = 5
while count > 0:
    print(count)
    count -= 1
```
**خروجی:**
```
5
4
3
2
1
```

#### **ب) دریافت ورودی تا زمانی که کاربر "exit" وارد کند**
```python
while True:
    user_input = input("یک عبارت وارد کنید (یا exit برای خروج): ")
    if user_input.lower() == "exit":
        break
    print(f"شما وارد کردید: {user_input}")
```

---

## **3. کنترل جریان حلقه‌ها (`break`, `continue`, `else`)**
### **الف) `break` — خروج زودهنگام از حلقه**
```python
for num in range(10):
    if num == 5:
        break  # حلقه در num=5 متوقف می‌شود
    print(num)
```
**خروجی:**
```
0
1
2
3
4
```

### **ب) `continue` — رد کردن یک تکرار**
```python
for num in range(10):
    if num % 2 == 0:
        continue  # اعداد زوج را رد می‌کند
    print(num)
```
**خروجی:**
```
1
3
5
7
9
```

### **ج) `else` — اجرای کد پس از اتمام حلقه**
```python
for num in range(3):
    print(num)
else:
    print("حلقه تمام شد!")
```
**خروجی:**
```
0
1
2
حلقه تمام شد!
```

---

## **4. توابع تکرارپذیر (`range`, `enumerate`, `zip`)**
### **الف) `range()` — تولید دنباله‌ای از اعداد**
```python
for i in range(5):       # 0 تا 4
    print(i)

for i in range(2, 6):    # 2 تا 5
    print(i)

for i in range(1, 10, 2): # 1 تا 9 با گام 2
    print(i)
```

### **ب) `enumerate()` — دریافت ایندکس و مقدار**
```python
fruits = ["سیب", "پرتقال", "موز"]
for index, fruit in enumerate(fruits):
    print(f"{index}: {fruit}")
```
**خروجی:**
```
0: سیب
1: پرتقال
2: موز
```

### **ج) `zip()` — ترکیب دو لیست**
```python
names = ["علی", "رضا", "مریم"]
ages = [25, 30, 28]

for name, age in zip(names, ages):
    print(f"{name}: {age} سال")
```
**خروجی:**
```
علی: 25 سال
رضا: 30 سال
مریم: 28 سال
```

---

## **5. List Comprehension — تکرار فشرده برای ساخت لیست**
```python
# ساخت لیست مربع اعداد 0 تا 9
squares = [x**2 for x in range(10)]
print(squares)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# فیلتر کردن اعداد فرد
odd_numbers = [x for x in range(10) if x % 2 != 0]
print(odd_numbers)  # [1, 3, 5, 7, 9]
```

---

## **6. توابع بازگشتی (Recursive Functions)**
تابعی که خودش را فراخوانی می‌کند.  
**مثال: محاسبه فاکتوریل**
```python
def factorial(n):
    return 1 if n == 1 else n * factorial(n - 1)

print(factorial(5))  # 120
```

---

## **نتیجه‌گیری**
| روش تکرار | کاربرد |
|-----------|--------|
| `for` | تکرار روی عناصر یک دنباله |
| `while` | تکرار تا زمانی که شرط برقرار است |
| `break` | خروج زودهنگام از حلقه |
| `continue` | رد کردن یک تکرار |
| `range()` | تولید دنباله عددی |
| `enumerate()` | دریافت ایندکس و مقدار |
| `zip()` | ترکیب دو لیست |
| List Comprehension | ساخت لیست به صورت فشرده |

# Decorator

کاربرد ات جا است که یک تابع داریم و می خواهیم کار قبلی را انحام دهد ولی یک دستور به ان اضافه شود

##  دکوراتور چیست؟
- دکوراتور یک تابع است که یک تابع دیگر را به عنوان ورودی می‌گیرد و یک تابع جدید را بازمی‌گرداند.
- از دکوراتورها برای اضافه کردن قابلیت‌های جدید به توابع موجود استفاده می‌شود.
- با استفاده از @decorator_name قبل از تعریف تابع اعمال می‌شوند.


## دکوراتورهای استاندارد پایتون
برخی دکوراتورهای داخلی پایتون:

|دکوراتور | کاربرد|
|--------|----------|
|@staticmethod	| تعریف متد استاتیک در کلاس|
|@classmethod	| تعریف متد کلاس|
|@property	| تعریف ویژگی‌های کلاس|

## کاربردهای رایج دکوراتورها
1. لاگ کردن (ثبت اطلاعات اجرا)

2. اعتبارسنجی (مثلاً چک کردن ورودی‌ها)

3. کش کردن (ذخیره نتایج برای عملکرد بهتر)

4. تعیین سطح دسترسی (مثلاً چک کردن لاگین کاربر)

5. تایمر (اندازه‌گیری زمان اجرا)

## فرم کلی
```py
import functools

def Decorator(func):
@functools.warps(func)
def warpper_decorator(*Args, **kwargs):
    #do somthing before
    value = func(*Args, **kwargs):
    # do somthing after
    return value
return warpper_decorator
```
## مثال :
```py

def dec(func):
    def inner(x, y):
        if y == 0:
            return "warning!!!"
        return func(x, y)
    return inner

@dec
def f(x, y)
    return x/y

print(f(10, 12))
#برای انکه بتوانیم از تابع بالا هر جا که خواستیم استفاده کنیم باید در تعریف متغیر (قبل ) از * استافده کنیم 
```
```py
def dec(func):
    def inner(*x, **y):
        if y == 0:
            return "warning!!!"
        return func(x, y)
    return inner

@dec
def f(x, y, z)
    return x/y+2

print(f(10, 12, 0))
```

## نکات مهم
- دکوراتورها می‌توانند تابع یا کلاس را تغییر دهند.

- ترتیب اعمال دکوراتورها مهم است (@A @B def f() معادل A(B(f)) است).

- برای حفظ متادیتاهای تابع اصلی (مثل __name__) از functools.wraps استفاده کنید.

مثال با functools.wraps:
```py
from functools import wraps

def debug(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print(f"فراخوانی {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@debug
def say_hello():
    """این تابع سلام می‌کند"""
    print("سلام!")

print(say_hello.__name__)  # خروجی: say_hello (بدون wraps میشد wrapper)
print(say_hello.__doc__)   # خروجی: این تابع سلام می‌کند
```
## جمع‌بندی
|مفهوم |	مثال |	کاربرد|
|--------|---------|-------|
|دکوراتور ساده	| @decorator	| اضافه کردن قابلیت جدید|
|دکوراتور با پارامتر	| @decorator(arg)	| پیکربندی دکوراتور|
|چند دکوراتور	| @A @B def f() |	ترکیب قابلیت‌ها|
|@property	| @property def x() |	کنترل دسترسی به ویژگی‌ها|































# شی گرای

 1. همه چیز در پایتون یک شی است
 2. هر شی حداقل باید نمونه ای از یک کلاس باشد
 3. یک متغیر, یک ارجاع به شی است
 4. هر کلاسی خود یک شی از کلاس(type) است و همه کلاس ها از کلاسی به اسم (object) ارث بری می کنند
 5. در ساختار جدید پایتون , مفهوم کلاس بری برابر مفهوم(type) در نظر گرفته شده است

## ایجاد کلاس
 - برای ایجاد کلاس مانند تابع عمل می کنیم و به جای کلمه (def) از (class) استفاده می کنیم

```
  class name:
    pass
```


[def]: ./D:/prog
[def2]: #تکرار-iteration-در-پایتون--حلقهها-و-روشهای-تکرار
[def3]: #3-کنترل-جریان-حلقهها-break-continue-else